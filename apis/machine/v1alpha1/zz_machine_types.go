/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BootConfigObservation struct {
}

type BootConfigParameters struct {

	// A valid cloud config data in json-escaped yaml syntax.
	// +kubebuilder:validation:Optional
	Content *string `json:"content,omitempty" tf:"content,omitempty"`
}

type ConstraintsObservation struct {
}

type ConstraintsParameters struct {

	// An expression of the form "[!]tag-key[:[tag-value]]", used to indicate a constraint match on keys and values of tags.
	// +kubebuilder:validation:Required
	Expression *string `json:"expression" tf:"expression,omitempty"`

	// Indicates whether this constraint should be strictly enforced or not.
	// +kubebuilder:validation:Required
	Mandatory *bool `json:"mandatory" tf:"mandatory,omitempty"`
}

type DisksListObservation struct {
	BlockDeviceID *string `json:"blockDeviceId,omitempty" tf:"block_device_id,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type DisksListParameters struct {
}

type DisksObservation struct {
}

type DisksParameters struct {

	// The id of the existing block device.
	// +kubebuilder:validation:Required
	BlockDeviceID *string `json:"blockDeviceId" tf:"block_device_id,omitempty"`

	// A human-friendly description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// A human-friendly block-device name used as an identifier in APIs that support this option.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ImageDiskConstraintsObservation struct {
}

type ImageDiskConstraintsParameters struct {

	// An expression of the form "[!]tag-key[:[tag-value]]", used to indicate a constraint match on keys and values of tags.
	// +kubebuilder:validation:Required
	Expression *string `json:"expression" tf:"expression,omitempty"`

	// Indicates whether this constraint should be strictly enforced or not.
	// +kubebuilder:validation:Required
	Mandatory *bool `json:"mandatory" tf:"mandatory,omitempty"`
}

type LinksObservation struct {
	Href *string `json:"href,omitempty" tf:"href,omitempty"`

	Hrefs []*string `json:"hrefs,omitempty" tf:"hrefs,omitempty"`

	Rel *string `json:"rel,omitempty" tf:"rel,omitempty"`
}

type LinksParameters struct {
}

type MachineObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	DisksList []DisksListObservation `json:"disksList,omitempty" tf:"disks_list,omitempty"`

	ExternalID *string `json:"externalId,omitempty" tf:"external_id,omitempty"`

	ExternalRegionID *string `json:"externalRegionId,omitempty" tf:"external_region_id,omitempty"`

	ExternalZoneID *string `json:"externalZoneId,omitempty" tf:"external_zone_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Links []LinksObservation `json:"links,omitempty" tf:"links,omitempty"`

	OrganizationID *string `json:"organizationId,omitempty" tf:"organization_id,omitempty"`

	Owner *string `json:"owner,omitempty" tf:"owner,omitempty"`

	PowerState *string `json:"powerState,omitempty" tf:"power_state,omitempty"`

	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type MachineParameters struct {

	// Machine boot config that will be passed to the instance that can be used to perform common automated configuration tasks and even run scripts after the instance starts.
	// +kubebuilder:validation:Optional
	BootConfig []BootConfigParameters `json:"bootConfig,omitempty" tf:"boot_config,omitempty"`

	// Constraints that are used to drive placement policies for entities such as image, network, storage, etc. Constraint expressions are matched against tags on existing placement targets.
	// +kubebuilder:validation:Optional
	Constraints []ConstraintsParameters `json:"constraints,omitempty" tf:"constraints,omitempty"`

	// Additional custom properties that may be used to extend the machine.
	// +kubebuilder:validation:Optional
	CustomProperties map[string]*string `json:"customProperties,omitempty" tf:"custom_properties,omitempty"`

	// The id of the deployment that is associated with this resource.
	// +kubebuilder:validation:Optional
	DeploymentID *string `json:"deploymentId,omitempty" tf:"deployment_id,omitempty"`

	// Describes machine within the scope of your organization and is not propagated to the cloud.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Specification for attaching/detaching disks to a machine.
	// +kubebuilder:validation:Optional
	Disks []DisksParameters `json:"disks,omitempty" tf:"disks,omitempty"`

	// +kubebuilder:validation:Required
	Flavor *string `json:"flavor" tf:"flavor,omitempty"`

	// Type of image used for this machine.
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// Constraints that are used to drive placement policies for entities such as image, network, storage, etc. Constraint expressions are matched against tags on existing placement targets.
	// +kubebuilder:validation:Optional
	ImageDiskConstraints []ImageDiskConstraintsParameters `json:"imageDiskConstraints,omitempty" tf:"image_disk_constraints,omitempty"`

	// +kubebuilder:validation:Optional
	ImageRef *string `json:"imageRef,omitempty" tf:"image_ref,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Nics []NicsParameters `json:"nics,omitempty" tf:"nics,omitempty"`

	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`
}

type NicsObservation struct {
}

type NicsParameters struct {

	// +kubebuilder:validation:Optional
	Addresses []*string `json:"addresses,omitempty" tf:"addresses,omitempty"`

	// +kubebuilder:validation:Optional
	CustomProperties map[string]*string `json:"customProperties,omitempty" tf:"custom_properties,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DeviceIndex *float64 `json:"deviceIndex,omitempty" tf:"device_index,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NetworkID *string `json:"networkId" tf:"network_id,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`
}

type TagsObservation struct {
}

type TagsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// MachineSpec defines the desired state of Machine
type MachineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MachineParameters `json:"forProvider"`
}

// MachineStatus defines the observed state of Machine.
type MachineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MachineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Machine is the Schema for the Machines API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vrajet}
type Machine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MachineSpec   `json:"spec"`
	Status            MachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MachineList contains a list of Machines
type MachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Machine `json:"items"`
}

// Repository type metadata.
var (
	Machine_Kind             = "Machine"
	Machine_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Machine_Kind}.String()
	Machine_KindAPIVersion   = Machine_Kind + "." + CRDGroupVersion.String()
	Machine_GroupVersionKind = CRDGroupVersion.WithKind(Machine_Kind)
)

func init() {
	SchemeBuilder.Register(&Machine{}, &MachineList{})
}
